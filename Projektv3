import os
import platform
import sys
import threading
import timeit
from itertools import repeat
from multiprocessing import Pool

import numpy as np

nums = [15972490, 80247910, 92031257, 75940266, 97986012, 87599664, 75231321, 11138524, 68870499, 11872796, 79132533,
        40649382, 63886074, 53146293, 36914087, 62770938]


def save(_results_thread1, _results_thread4, _results_proc4, _results_proc_cpus,
         median0, median1, median2, median3):
    version = platform.python_version()
    interpreter_version = sys.version
    interpreter = platform.python_implementation()
    system_version = platform.release()
    op_sys = platform.system()
    CPU = platform.processor()
    CPU_count = os.cpu_count()

    heading = """
        <html>
        <head>
        <title>Report</title>
        <style>
        table, th, td {{
            border: 2px solid gray;
            border-collapse: collapse;
            padding:10px
        }}
        </style>
        <meta charset="utf-8">
        </head>
        <body>
        <h1>Results for multiple threads / processes</h1>
        <h3>Environment</h3>
        <table>
        <tr><td><strong>Python version:</strong></td><td>{}</td></tr>
        <tr><td><strong>Interpreter:</strong></td><td>{}</td></tr>
        <tr><td><strong>Interpreter version:</strong></td><td>{}</td></tr>
        <tr><td><strong>Operating System:</strong></td><td>{}</td></tr>
        <tr><td><strong>Operating system version:</strong></td><td>{}</td></tr>
        <tr><td><strong>Procesor:</strong></td><td>{}</td></tr>
        <tr><td><strong>Number of CPUs:</strong></td><td>{}</td></tr>
        </table> <br>
        <h3>Test results</h3>
        <table>
        <thead>
        <tr>
        <th>&nbsp;</th>
        <th>1 threads [s]</th>
        <th>4 threads [s]</th>
        <th>4 processes [s]</th>
        <th><CPUs> processes [s]</th>
        </tr>
        </thead>
        <tbody>
        """.format(version, interpreter, interpreter_version,
                   op_sys, system_version,
                   CPU, CPU_count)
    end = """
        </tbody>
        </table> <br>
        <h3>Summary</h3>
        <table>
        <thead>
        <tr>
        <th>&nbsp;</th>
        <th>1 thread [s]</th>
        <th>4 threads [s]</th>
        <th>4 processes [s]</th>
        <th><CPUs> processes [s]</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><strong>Median</strong></td>
        <td>{:.4f}</td> 
        <td>{:.4f}</td>
        <td>{:.4f}</td>
        <td>{:.4f}</td>
        </tr>
        </tbody>
        </table>
        <br>
        <h3>Author: Jakub Marcinkowski</h3>
        </body>
        </html>
        """.format(float(median0), float(median1), float(median2), float(median3))
    middle = "".join(
        "<tr><td>{}</td><td>{:.4f}</td><td>{:.4f}</td><td>{:.4f}</td><td>{:.4f}</td></tr>\n".format(
            i + 1,
            _results_thread1[0],
            _results_thread4[0],
            _results_proc4[0],
            _results_proc_cpus[0],
        )
        for i in range(len(_results_thread1))
    )

    with open("cpython_results.html", "w", encoding="utf-8") as f:
        f.write(heading + middle + end)


def ranges(num, processes):
    if processes <= 1:
        return [(1, num)]
    part = num // processes
    remainder = num % processes
    tasks = []
    i = 0
    while i + part < num:
        previous_i = i
        i += part if i + part <= num else num
        task = (previous_i + 1, i)
        tasks.append(task)
    tasks[-1] = tasks[-1][0], tasks[-1][0] + part + remainder - 1
    return tasks


def f(_range, n):
    x, y = _range
    return sum((n - i) * i for i in range(x, y))


def multiprocessing(tasks, n):
    if len(tasks) == 1:
        return f(tasks[0], n)
    with Pool(len(tasks)) as p:
        results = p.starmap(f, zip(tasks, repeat(n)))
    return sum(results)


def multithreading(tasks, n):
    if len(tasks) == 1:
        return f(tasks[0], n)
    for task in tasks:
        thread = threading.Thread(target=f, args=(task, n,))
        thread.start()


def calculate_with_processes(processes=1):
    results = []
    for number in nums:
        tasks = ranges(number, processes)
        time = timeit.timeit(lambda: multiprocessing(tasks, number), number=4)
        mean_time = time / 4
        results.append(mean_time)
    return results


def calculate_with_threads(threads=1):
    results = []
    for number in nums:
        tasks = ranges(number, threads)
        time = timeit.timeit(lambda: multithreading(tasks, number), number=4)
        mean_time = time / 4
        results.append(mean_time)
        print(number, ":", mean_time)
    return results


if __name__ == '__main__':
    print("przeprowadzanie obliczeń na 1 wątku")
    results_thread1 = calculate_with_threads(1)
    print("przeprowadzanie obliczeń na 4 wątkach")
    results_thread4 = calculate_with_threads(4)
    print("przeprowadzanie obliczeń na 4 procesach")
    results_proc4 = calculate_with_processes(4)
    print("przeprowadzanie obliczeń na liczbie procesów równej ilości CPU")
    results_proc_CPUs = calculate_with_processes(os.cpu_count())

    median0 = np.median(results_thread1)
    median1 = np.median(results_thread4)
    median2 = np.median(results_proc4)
    median3 = np.median(results_proc_CPUs)
    save(results_thread1, results_thread4, results_proc4, results_proc_CPUs, median0, median1, median2, median3)
